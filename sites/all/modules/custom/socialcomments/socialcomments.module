<?php
/**
 * @file socialcomments.module
 *
 * Display drupal comments in a "youtube-like" way on selected content types:
 * - we can vote on comments (using rate module)
 * - only one level on children comments is allowed
 * - top rated comments are displayed to the top of the comments
 *
 * INSTALLATION :
 * Use this code in settings.php to enable this module,
 * to provide some required configuration :
 * @code
 * // on which content types socialcomments are enabled. None by default.
 * $conf['socialcomments']['content_types'] = array(
 *   'measurement'
 * );
 * @encode
 */

/* =========================
     Hooks
   ========================= */

/**
 * Implements hook_node_view()
 *
 * Replace native comment system display by our own.
 * @param $node
 * @param $view_mode
 */
function socialcomments_node_view($node, $view_mode) {

  $conf = variable_get('socialcomments', array());

  // only on allowed content types
  if (empty($conf['content_types']) || !in_array($node->type, $conf['content_types'])) return;

  // ! DO NOT REMOVE !
  // we remove all ids generated by rate module with drupal_html_id function,
  // because it will broke rate module javascript.
  // This is because rate module is called two times when this module is enabled;
  // because we override $node->content['comments']
  // (that was previously calculated by comment_node_view fucntion)
  $html_ids = &drupal_static('drupal_html_id');
  if ($html_ids) {
    foreach ($html_ids as $key => $value) {
      if (strpos($key, 'rate-comment') !== FALSE) {
        unset($html_ids[$key]);
      }
    }
  }

  // override native comments system.
  $node->content['comments'] = socialcomments_build_renderable_array($node);

}


/**
 * Implements hook_ajax_render_alter()
 *
 * Catch ajax commands from ajax_comments module, and add a instruction to
 * scroll to the bottom of the comments after user inserted a new comment.
 *
 * @param $commands
 */
function socialcomments_ajax_render_alter(&$commands) {
  foreach ($commands as $i => $command) {
    // if we find "ajaxCommentsAfter", ajax_comments is inserting a new comment;
    // so add our scroll here, toward the bottom of the comments.
    if ($command['command'] == 'ajaxCommentsAfter') {
      $commands[] = array('command' => 'ajaxCommentsScrollToElement', 'selector' => '#socialcomments-bottom');
    }
  }
}


/* =========================
     API
   ========================= */

/**
 * Display all "root" comments, sort by number of votes (descending) : "root" comments
 * are comments which are not children of another comment.
 *
 * @param int $nid : node nid
 * @param array $options
 * @param int $limit : number of parents comments to display (does not take in account CHILDREN comments)
 * @return mixed
 */
function socialcomments_get_parent_comments($nid, $options = array(), $limit = 200) {

  $query = db_select('comment', 'c')->extend('PagerDefault');

  // postgre sql sorts NULL values first, we change NULL in -999999 to
  // have null values sorted in last position
  $query->addExpression("COALESCE(v.value, -999999)", 'points');

  $query->addField('c', 'cid');
  $query->leftJoin('votingapi_cache', 'v', "c.cid = v.entity_id AND v.function='average'");

  $query
    ->condition('c.nid', $nid)
    ->condition('c.pid', 0)
    //->condition('v.function', 'average')
    ->addTag('node_access')
    ->limit($limit);

  $count_query = db_select('comment', 'c');
  $count_query->addExpression('COUNT(*)');
  $count_query
    ->condition('c.nid', $nid)
    ->condition('c.pid', 0)
    ->addTag('node_access');

  if (!user_access('administer comments')) {
    $query->condition('c.status', COMMENT_PUBLISHED);
    $count_query->condition('c.status', COMMENT_PUBLISHED);
  }

  // only parent comments
  $query->orderBy("points", 'DESC');

  $query->setCountQuery($count_query);
  $cids = $query->execute()->fetchCol();

  return $cids;
}

/**
 * Get direct children comments (depth +1 ) for a specific comment
 * @param int $comment_id : parent comment id
 *
 * @return array of comment_ids
 */
function socialcomments_get_children_comments($comment_id) {
  $query = db_select('comment', 'c');
  $query->addField('c', 'cid');
  $query->condition('c.pid', $comment_id);
  $query->orderBy('c.cid');
  $cids = $query->execute()->fetchCol();
  return $cids;
}

/* =========================
     Helpers functions
   ========================= */

/**
 * Rebuild the comment-related elements for node detail pages.
 * This is a copy / paste of comment_node_page_additions() core function, with a few tweaks
 *
 * We create a "renderable array" of parent comments and their children comments.
 *
 * @param $node
 *  A node object.
 * @return array
 */
function socialcomments_build_renderable_array($node) {

  // global renderable array for comments (containing comments and comment form)
  $render_array = array();

  // Only attempt to render comments if the node has visible comments.
  // Unpublished comments are not included in $node->comment_count, so show
  // comments unconditionally if the user is an administrator.
  if (($node->comment_count && user_access('access comments')) || user_access('administer comments')) {

    // get only top parents comments first
    if ($comments_parents_cids = socialcomments_get_parent_comments($node->nid)) {

      $comments_parents = comment_load_multiple($comments_parents_cids);
      $comments_parents_render_array = comment_view_multiple($comments_parents, $node);
      $comments_render_array = array();
      // use weight to make sure children comments are display BELOW their parent comment.
      $weight = 0;
      foreach ($comments_parents_render_array as $comment_parent_cid => $array) {

        // skip all elements beginning by '#'
        if (strpos($comment_parent_cid, '#') === 0) continue;

        $comments_render_array[$comment_parent_cid]['parent'] = $comments_parents_render_array[$comment_parent_cid];
        $comments_render_array[$comment_parent_cid]['parent']['#weight'] = $weight;

        $children_cids = socialcomments_get_children_comments($comment_parent_cid);
        $children_comments = comment_load_multiple($children_cids);
        $comments_children_render_array = comment_view_multiple($children_comments, $node);

        // update link href to reply to "parent" comment instead of "child comment",
        // because we only have one level of child comments, like youtube.
        foreach ($comments_children_render_array as $i => $child_build) {

          // remove possibility to vote for children comments.
          if (isset($comments_children_render_array[$i]['rate_qualification_vote'])) {
            unset($comments_children_render_array[$i]['rate_qualification_vote']);
          }

          if (empty($comments_children_render_array[$i]['links']['comment']['#links']['comment-reply']['href'])) continue;

          $href = $comments_children_render_array[$i]['links']['comment']['#links']['comment-reply']['href'];
          $href_parts = explode('/', $href);
          $href_parts[3] = $comment_parent_cid;
          $comments_children_render_array[$i]['links']['comment']['#links']['comment-reply']['href'] = implode('/', $href_parts);

        };

        $comments_render_array[$comment_parent_cid]['children'] = $comments_children_render_array;
        $comments_render_array[$comment_parent_cid]['children']['#weight'] = ++$weight;
        $comments_render_array[$comment_parent_cid]['children']['#prefix'] = '<div class="thread-wrapper indented">';
        $comments_render_array[$comment_parent_cid]['children']['#suffix'] = '</div>';


      }

      // $comments_render_array['pager']['#theme'] = 'pager';
      $render_array['comments'] = $comments_render_array;
      // this is a hack : we want user to scroll to the bottom of the comments
      // when it just inserted a new comment from main comment form.
      // @see socialcomments_ajax_render_alter()
      $render_array['comments']['#suffix'] = '<div style="position:relative;top:-200px" id="socialcomments-bottom"></div>';
    }
  }

  // Append comment form if needed.
  if (user_access('post comments') && $node->comment == COMMENT_NODE_OPEN && (variable_get('comment_form_location_' . $node->type, COMMENT_FORM_BELOW) == COMMENT_FORM_BELOW)) {
    $comment_form_render_array = drupal_get_form("comment_node_{$node->type}_form", (object) array('nid' => $node->nid));
    $render_array['comment_form'] = $comment_form_render_array;
  }

  if ($render_array) {
    $render_array += array(
      '#theme' => 'comment_wrapper__node_' . $node->type,
      '#node' => $node,
      'comment_form' => array(),
      'comments' => array(),
    );
  }
  return $render_array;
}